/*!
 *
 */
#ifndef IRIS_AGENT_HPP_
#define IRIS_AGENT_HPP_

#include <memory>
#include <mutex>
#include <unordered_map>
#include <utility>
#include <vector>

#include "iris/Parameters.hpp"
#include "iris/Types.hpp"

namespace iris
{    
    /*!
     * Represents the cumulative state of comminicative interaction between a
     * pair of agents at some time <i>t</i>.
     *
     * When an agent is written to an output stream, such as during a
     * checkpoint, these quantities are converted to probabilities.  Specific
     * formulae are as follows:
     *  -# The communication probability <i>P(C)</i> is generated by dividing
     *  the number of communication events (<i>m_communicated</i>) by the
     *  number of possible events.  For some <i>t</i>, the total number of
     *  possible communication events is <i>2t</i>.
     *  -# The influence probability is obtained by adding together the
     *  number of censored events (<i>m_censored</i>) and the number of
     *  reinforcement events (<i>m_reinforced</i>) divided by the number of
     *  communication events that have occured thus far.  An identical
     *  formula can be used for either sub-quantity alone.
     */
    struct Interaction
    {
        /*!
         * Represents the number of times an agent has censored another
         * because of her behavior.
         *
         * One agent censored another if the first agent and the second
         * agent's behaviors are different, and the second agent decides to
         * change her behavior after an interaction with a group of m agents
         * (including the first).
         */
        types::unumeric m_censored;

        /*!
         * Represents the number of times a pair of agents have communicated
         * with one another in some way.
         *
         * For purposes of this simulation, "communication" and "interaction"
         * are one and the same.  An agent communicates to another by
         * randomly selecting them from either her "in" or "out" social
         * networks, respectively.
         */
        types::unumeric m_communicated;

        /*!
         * Represents the number of times an agent has reinforced another
         * using her behavior.
         *
         * One agent reinforces another if both the first and second
         * agent's behaviors match, and the second agent does not decide to
         * change her behavior after an interaction with a group of m agents
         * (including the first).
         */
        types::unumeric m_reinforced;
    };

    /*!
     * Represents the state of an agent in terms of the behaviors she exhibits
     * at some time <i>t</i>.
     */
    struct State
    {
        /*!
         * The time that this step was updated at.
         *
         * This does <i>not</i> correspond to any real measurement of time.
         * Instead, <i>m_time</i> represents the current step count when the
         * behavior list was updated.
         */
        types::uint64   m_time;

        /*!
         * The list of current behaviors at some time <i>t</i>.
         */
        BehaviorList    m_behavior;

        /*!
         * Assignment operator.
         *
         * @param state
         *        The state to copy from.
         * @return A reference to this state.
         */
        State& operator = (const State& state);
    };
    
    class Agent
    {
        public:
            typedef std::vector<AgentID>                     Network;
            typedef std::unordered_map<AgentID, Interaction> InteractionMap;
            typedef std::pair<types::uint32, types::uint32>  Sides;
            typedef std::lock_guard<std::mutex>              mutex_guard;
            
        public:            
            /*!
             * Represents the type of interpersonal interactions that may
             * occur between agents.
             */
            enum CommType
            {
                /*!
                 * Represents that an agent exerted her influence to censor
                 * another, increasing the probability that the other's
                 * behavior will change.
                 */
                Censored,

                /*!
                 * Represents that an agent did not have any influence on
                 * another and thus neither censored nor reinforced their
                 * behavior choices.
                 */
                Neither,

                /*!
                 * Represents that an agent exerted her influence to support
                 * another, increasing the probability that the other's
                 * behavior will remain the same.
                 */
                Reinforced,
            };

            /*!
             * Represents the overall outcome of an interpersonal interaction.
             */
            enum Outcome
            {
                /*!
                 * Represents an interaction where an agent was forced to
                 * change their behavior.
                 */
                Change,

                /*!
                 * Represents an interaction where an agent did not change
                 * their behavior.
                 */
                Keep,
            };

            /*! Constructor. */
            Agent();

            /*! Destructor. */
            ~Agent();

            /*!
             *
             *
             * @param params
             * @param agents
             * @param totalAgents
             * @param behaviors
             * @param time
             * @param random
             */
            void step(const Parameters& params,
                      Agent* const agents,
                      AgentID totalAgents,
                      const BehaviorList& behaviors,
                      types::uint64 time,
                      types::mersenne_twister& random);

        public:
            // The following functions are used exclusively by each agent every
            // time step to compute their behavioral result.
            //
            // These methods are grouped together to make them easy to unit test
            // (and find).

            BehaviorList cacheBehaviorsAsSet(const Network& powerGroup,
                                             Agent* const agents,
                                             types::uint32 index,
                                             types::uint64 time);

            Outcome computeOutcomeDirectly(const Sides& sides) const;

            Outcome computeOutcomeSociodynamically(const Sides& sides,
                                                   const Parameters& params,
                                         types::mersenne_twister& random) const;
            
            Sides computeSides(types::uint32 index,
                               types::uint32 behavior,
                               Network socialGroup,
                               Agent* const agents,
                               AgentID totalAgents,
                               types::uint64 time) const;

            CommType determineCommType(const types::uint32& me,
                                       const types::uint32& you,
                                       const Outcome& outcome);

            void distributePrivilege(types::uint32 currentIndex,
                                     types::uint32 currentBehavior,
                                     const Network& socialGroup,
                                     const Outcome& outcome,
                                     Agent* const agents,
                                     types::uint64 time);

            void distributePrivilegeWithPower(types::uint32 currentIndex,
                                              types::uint32 currentBehavior,
                                              const Network& socialGroup,
                                              const Network& powerGroup,
                                              const Outcome& outcome,
                                              Agent* const agents,
                                              types::uint64 time);
        
        
            /*!
             *
             *
             * @param lambda
             *
             * @param x
             *
             * @return
             */
            types::fnumeric computeUtility(types::fnumeric lambda,
                                           types::uint32 x) const;
            
            
            Network extractPowerful(const Network& network, Agent* const agents,
                                    AgentID totalAgents);

            Network obtainRandomInfluentialGroup(types::uint32 qIn,
                                                 types::uint32 qOut,
                                                 Agent* const agents,
                                                 AgentID totalAgents,
                                               types::mersenne_twister& random);
            
            /*!
             *
             *
             * @param qIn
             *        The 
             * @return
             */
            Network obtainRandomInGroup(types::uint32 qIn,
                                        types::mersenne_twister& random);

            /*!
             *
             *
             * @param qOut
             *
             * @param totalAgents
             *
             * @return
             */
            Network obtainRandomOutGroup(types::uint32 qOut,
                                         AgentID totalAgents,
                                         types::mersenne_twister& random);

            void removeNonPowerful(Network& network, Agent* const agents,
                                   AgentID totalAgents);

            types::uint32 selectNewBehavior(types::uint32 currentBehavior,
                                            types::uint32 behaviorRange,
                                            types::mersenne_twister& random);

        public:
            // The following functions are used as accessors by the graph
            // generation framework.

            /*!
             * Adds the specified agent (given as a unique identifier) to this
             * agent's social network.
             *
             * Please note that this function does <i>not</i> sort the social
             * network.
             *
             * @param to
             *        The unique id of the agent to add to the network.
             */
            void addConnection(AgentID to);

            types::uint32 getBehaviorAt(types::uint32 index,
                                        types::uint64 time);

            InteractionMap::iterator getInteractionsWith(const AgentID& id);
            
            /*!
             * Increases the amount of privilege this agent possesses by one.
             */
            void increasePrivilege();

            /*!
             * Returns whether or not this agent is already connected to the
             * specified agent.
             *
             * @param to
             *        The agent to check for.
             * @return Whether or not the agent is present in the network.
             */
            bool isConnectedTo(AgentID to);
            
            /*!
             * Sets the size of the family to which this agent belongs.
             *
             * @param familySize
             *        The number of total agents in a family.
             */
            void setFamilySize(types::uint32 familySize);
            
            /*!
             * Sets the initial vector of behaviors for this agent.
             *
             * The vector of behaviors is a collection of independent discrete
             * variables.
             *
             * @param behavior
             *        The vector of behaviors to use.
             */
            void setInitialBehavior(BehaviorList behavior);

            /*!
             * Sets the initial vector of values for this agent.
             *
             * The vector of values is a collection of independent discrete
             * variables.
             *
             * @param values
             *        The vector of values to use.
             */
            void setInitialValues(ValueList values);

            /*!
             * Sets whether or not this agent is "powerful" in terms of
             * simulation dynamics.
             *
             * @param isPowerful
             *        Whether or not to be considered "powerful".
             */
            void setPowerful(bool isPowerful);
            
            /*!
             * Sets the unique identifier for this agent.
             *
             * @param uid
             *        The (new) unique identifier to use.
             */
            void setUId(AgentID uid);

            void updateCommunicationWith(const Network& network);
            
            void updateInfluenceOn(const AgentID& targetId,
                                   const CommType& commType);
            
            void updateState(types::uint32 index, types::uint32 behavior,
                             types::uint64 time);
            
        public:
            // The following methods are used as accessors by the I/O
            // framework in order to output graph information.
            //
            // All of these methods return "const" objects to preserve the
            // integrity of the underlying data as well as ensure thread safety.
            
            /*!
             * Returns the current list of behaviors for this agent.
             *
             * Please note that it is expected that this method will only be
             * called <i>after</i> a simulation step has completed (e.g. for
             * checkpointing) and thus is not intended, nor guaranteed to be
             * safe, to call during a threaded execution cycle.
             *
             * @return The current list of behaviors.
             */
            BehaviorList getBehavior() const;

            types::uint32 getBehaviorCount() const;

            /*!
             * Returns the total number of other connections 
             */
            types::uint32 getFamilyConnections() const;
            
            /*!
             * Returns the number of agents that comprise this agent's family.
             *
             * @return The size of the family.
             */
            types::uint32 getFamilySize() const;
            
            /*!
             * Returns the map of communication events that have transpired
             * between this agent and all other agents she has encountered
             * since the start of the simulation.
             *
             * @return The communication map.
             */
            InteractionMap getInteractions() const;
            
            /*!
             * Returns the social (egocentric) network with this agent as its
             * center.
             *
             * As stated elsewhere, this network is purely an <i>input</i>
             * network; it contains only links from other agents to this one
             * that act as the "in" group to which she belongs.
             *
             * @return The social network.
             */
            Network getNetwork() const;
            
            /*!
             * Returns the amount of privilege this agent possesses.
             *
             * Please note that for simulations with no powerful agents
             * participating, this will always be zero.
             *
             * @return The amount of privilege.
             */
            types::unumeric getPrivilege() const;

            /*!
             * Returns the unique id associated with this agent.
             *
             * Z@return The unique id.
             */
            AgentID getUId() const;

            /*!
             * 
             *
             * @return The list of values.
             */
            ValueList getValues() const;

            /*!
             *
             */
            bool isNetworkFull(types::uint32 outConnections,
                               AgentID totalAgents) const;
            
            /*!
             * Returns whether or not this agent is "powerful", which is
             * important because powerful agents interact with the simulation
             * differently.
             *
             * @return Whether or not an agent is powerful.
             */
            bool isPowerful() const;
            
        private:
            types::uint32          m_familySize;
            InteractionMap         m_interactions;
            Network                m_network;
            bool                   m_powerful;
            types::atomic_unumeric m_privilege;
            State                  m_state[2];
            AgentID                m_uid;
            ValueList              m_values;

        private:
mutable            std::mutex     m_bMutex;
mutable            std::mutex     m_iMutex;
    };
}

#endif
